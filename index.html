<title>Arkanoid en JavaScript</title>
<style>
    body {
        background-color: #f0f0f0;
        display: grid;
        place-content: center;
    }

    canvas {
        border: 4px solid #000;
        border-bottom: transparent;
        background: url('./assets/img/bkg.png');
        margin: 0 auto;
        display: block;
        box-shadow: 0px 0px 20px 0px rgb(0, 0, 0, 0.4);
    }
</style>

<canvas></canvas>

<img hidden id="sprite" src="./assets/img/sprite.png" alt="Sprite Arkanoid" />
<img hidden id="bricks" src="./assets/img/bricks.png" alt="Sprite Bricks Arkanoid" />

<script>
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');

    const $sprite = document.querySelector('#sprite');
    const $bricks = document.querySelector('#bricks');

    canvas.width = 448;
    canvas.height = 400;

    /* Game variables */
    let isPaused = true;  //to track the game state
    let counter = 0;  // contador de puntos
    /* Ball variables */
    const ballRadius = 3;
    //Ball position
    let x = canvas.width / 2;
    let y = canvas.height - 30;
    //ball speed
    let dx = -3;
    let dy = -3;

    /* Paddle variables */
    const PADDLE_SENSITIVITY = 8;

    const paddleHeight = 10;
    const paddleWidth = 50;
    
    let paddleX = (canvas.width - paddleWidth) / 2;
    let paddleY = canvas.height - paddleHeight - 10;

    let rightPressed = false;
    let leftPressed = false;

    /* Bricks variables */
    const brickRowCount = 6;
    const brickColumnCount = 13;
    const brickWidth = 32;
    const brickHeight = 16;
    const brickPadding = 0;
    const brickOffsetTop = 80;
    const brickOffsetLeft = 16;
    const bricks = [];

    const BRICK_STATUS = {
        ACTIVE: 1,
        DESTROYED: 0
    }

    for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];  //inicializamos con un array vacio
        for (let r = 0; r < brickRowCount; r++) {
            //calculamos la posicion del ladrillo en la pantalla
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            //Asignar un color aleatorio a cada ladrillo
            const random = Math.floor(Math.random() * 8);
            //guardamos el estado del ladrillo en la posicion c,r
            bricks[c][r] = {
                x: brickX,
                y: brickY,
                status: BRICK_STATUS.ACTIVE,
                color: random
            }
        }
    }

    //dibujar contador
    function drawCounter() {
        const counterString = counter.toString().padStart(6, '0');
        const counterX = canvas.width - 60;  //posicion X del contador
        const counterY = 20;  //posicion Y del contador
        ctx.font = '600 16px Arial';  //tamaño de fuente
        ctx.fillStyle = '#ff7a33';  //color de fuente
        ctx.fillText('Puntos:', counterX -60, counterY);  //texto a dibujar
        ctx.fillText(counterString, counterX, counterY);  //valor del contador a dibujar
    }

    function drawBall() {
        ctx.beginPath();  //iniciar el trazado
        ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.closePath();  //cerrar el trazado
    };

    function drawPaddle() {
        ctx.drawImage(
            $sprite,    //imagen
            29,         //clipX: coordenadas de recorte
            174,        //clipY : coordenadas de recorte
            paddleWidth,    //el tamaño del recorte
            paddleHeight,   //el tamaño del recorte
            paddleX,        //la posición X de la imagen
            paddleY,        //la posición Y de la imagen
            paddleWidth,    //ancho de la imagen
            paddleHeight    //alto de la imagen
        )
    };

    function drawBricks() {
        for (let c = 0; c < brickColumnCount; c++) {
            for (let r = 0; r < brickRowCount; r++) {
                const currentBrick = bricks[c][r];
                if(currentBrick.status === BRICK_STATUS.DESTROYED) continue;

                const clipX = currentBrick.color * 32;

                ctx.drawImage(
                    $bricks,    
                    clipX,         
                    0,        
                    brickWidth,  //31
                    brickHeight,   //14
                    currentBrick.x,        
                    currentBrick.y,        
                    brickWidth,    
                    brickHeight    
                )
            }
        }
    };

    //pause the game
    function startGame() {
        isPaused = false;
        if(!gameLoop) {
            gameLoop = setInterval(draw, msPerFrame);
        }
    }

    function drawUI() {
        ctx.fillText(`FPS: ${framePerSec}`,5, 10);
    }

    function collisionDetection() {
        for(let c = 0; c < brickColumnCount; c++) {
            for(let r = 0; r < brickRowCount; r++) {
                const currentBrick = bricks[c][r];
                if(currentBrick.status === BRICK_STATUS.DESTROYED) continue;

                const isBallSameXAsBrick = 
                x > currentBrick.x && x < currentBrick.x + brickWidth;

                const isBallSameYAsBrick =
                y > currentBrick.y && y < currentBrick.y + brickHeight;

                if(isBallSameXAsBrick && isBallSameYAsBrick) {
                    dy = -dy;
                    currentBrick.status = BRICK_STATUS.DESTROYED;
                    counter += 5;  // aumentar el contador en 5 puntos
                }
            }
        }
    };

    function ballMovement() {
        if(x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
            dx = -dx;
        }
        
        if(y + dy < ballRadius) {
            dy = -dy;
        }

        // the ball hits the paddle
        const isBallSameXAsPaddle = x > paddleX && x < paddleX + paddleWidth;

        const isBallTouchingPaddle = y + dy > paddleY

        if(isBallSameXAsPaddle && isBallTouchingPaddle) {
            dy = -dy;  //change the ball's direction
            //ball touches the floor
        } else if(y + dy > canvas.height - ballRadius || y + dy > paddleY + paddleHeight) {
            gameOver = true;
            console.log('Game Over');
            document.location.reload();
        }

        //move the ball
        x += dx;
        y += dy;
    };

    function paddleMovement() {
        if(rightPressed && paddleX < canvas.width - paddleWidth) {
            paddleX += PADDLE_SENSITIVITY;
        } else if(leftPressed && paddleX > 0) {
            paddleX -= PADDLE_SENSITIVITY;
        }
    };

    function cleanCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    };

    function initEvents() {
        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);

        function keyDownHandler(event) {
            const { key } = event;
            if(key === 'Right' || key === 'ArrowRight' || key.toLowerCase() === 'd') {
                rightPressed = true;
            } else if(key === 'Left' || key === 'ArrowLeft' || key.toLowerCase() === 'a') {
                leftPressed = true;
            }
        }

        function keyUpHandler(event) {
            const { key } = event;
            if(key === 'Right' || key === 'ArrowRight' || key.toLowerCase() === 'd') {
                rightPressed = false;
            } else if(key === 'Left' || key === 'ArrowLeft' || key.toLowerCase() === 'a') {
                leftPressed = false;
            }
        }
    }

    //velocidad de animacion en frames por segundo
    const fps = 60;

    let msPrev = window.performance.now();
    let msFPSPrev = window.performance.now() + 1000;
    const msPerFrame = 1000 / fps;
    let frames = 0;
    let framePerSec = fps;

    let gameOver = false;

    function draw() {
        if(gameOver) {
            counter = 0;  // resetear el contador
            return
        };

        window.requestAnimationFrame(draw);

        const msNow = window.performance.now();
        const msPassed = msNow - msPrev;

        if(msPassed < msPerFrame) return;

        const excessTime = msPassed % msPerFrame;
        msPrev = msNow - excessTime;

        frames++;

        if(msFPSPrev < msNow) {
            msFPSPrev = window.performance.now() + 1000;
            framePerSec = frames;
            frames = 0;
        }

        //dibujar elementos
        cleanCanvas();
        drawBall();
        drawPaddle();
        drawBricks();
        drawUI();
        drawCounter();  // dibujar contador
        //colisiones y movimientos
        collisionDetection();
        ballMovement();
        paddleMovement();
        
    };

    draw()
    initEvents();
</script>